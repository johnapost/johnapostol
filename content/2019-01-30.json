{
  "date": "2019-01-30",
  "title": "Using Redux with Vanilla JS",
  "preview": "What follows is an explanation of how I've used Redux to make a production vanilla JS app more maintainable.",
  "slug": "using-redux-with-vanilla-js",
  "tags": [
    "software",
    "javascript"
  ],
  "bodyContent": "![wide](hero.jpg)\r\n\r\nRedux is a popular state management library for JavaScript apps that is routinely paired with frameworks like React or Angular. What follows is an explanation of how I’ve used Redux to make a production vanilla JS app more maintainable.\r\n\r\nI’m hoping this is useful for anyone out there who is looking for a real-world Redux + vanilla JS example beyond a button incrementer or to-do app.\r\n\r\n---\r\n\r\n# Background\r\n\r\nLet’s go back to late 2017/early 2018. The subject app is in production and has ~8 engineers actively developing. This ain’t your trendy universal React app. It’s purpose-built for managing content for our company.\r\n\r\nThe backend framework is Django and includes Wagtail as a CMS. The frontend is babel-transpiled vanilla JS with SCSS as a preprocessor. Templates are all handled by Django’s built-in templating system.\r\n\r\nThe frontend app has its roots in the Knockout JS framework, but this was reduced to vanilla JS in pursuit of faster page loads and script executions. Most of the frontend logic is meant to handle simple features like sharing to social networks, subscribing to a newsletter, and submitting forms.\r\n\r\nEach page stands alone and references its own template CSS file for styles, and template JS file for logic. Since we don’t use a frontend framework at runtime, the pages are much faster than our competitors.\r\n\r\n---\r\n\r\n# Identifying the problems\r\n\r\nAs our app grew, we had to support more CMS templates that were used for even more pages. Common bugs would appear and reappear as we worked. Problems fell into two categories.\r\n\r\n## 1. Code reuse was arbitrary and difficult\r\n\r\nOur frontend code had duplication stemming from over-eager classical inheritance patterns. There were multiple levels of inheritance that had to be traversed to understand how a certain page’s logic would differ from another, very similar page.\r\n\r\nThis got worse with time.\r\n\r\nTemplate functionality requirements were fluid. It was hard for newer hires to conform to the intricate inheritance layers when making changes. A ticket would be raised to fix a bug on one page with the assumption that it would apply to all templates. Unfortunately, that wasn’t the case.\r\n\r\n## 2. Asynchronous data, without any management\r\n\r\nSome code would make asynchronous data requests to a separate server. The response data existed only within the context of the requesting function. This was fine until we ran into situations where we wanted to share data between separate functions.\r\n\r\nSome features required data from multiple asynchronous functions and an engineer would have to manually invoke those functions and do it in the right order. It wasn’t immediately clear what that order was and why it was important until bugs cropped up in staging environments.\r\n\r\nIt was especially awful with the duplication and confusing inheritance patterns already pervasive in the code. Plus, unit test coverage wasn’t very good.\r\n\r\n---\r\n\r\n# Composing a solution with Redux\r\n\r\nI audited the entirety of the frontend application and reduced all logic into small building blocks called **features**. These features almost never interacted with each other. They simply wanted to run, process some template data, attach event handlers to the DOM, and had no need to exist after that.\r\n\r\nOur app’s multilevel inheritance structure only existed to group features common to a template. I could accomplish the same thing and reduce cognitive load by simply composing our features together.\r\n\r\nfor this, I used the `compose()` utility that Redux provides. See what kind of effect it has on the code below.\r\n\r\n## Before: multilevel inheritance\r\n\r\n```js\r\nclass BasePage {\r\n  constructor() { console.log('Setting up base page') }\r\n};\r\n\r\nclass HeaderPage extends BasePage {\r\n  constructor() {\r\n    super();\r\n    this.initHeader();\r\n  }\r\n  initHeader() { console.log('Initializing header') }\r\n};\r\n\r\nclass FormPage extends HeaderPage {\r\n  constructor() {\r\n    super();\r\n    this.initForm();\r\n  }\r\n  initForm() { console.log('Initializing form') }\r\n};\r\n\r\nclass FormNoHeader extends FormPage {\r\n  constructor() { super() }\r\n  // Empty method so that this.initHeader() in FormPage constructor does nothing\r\n  initHeader() {}\r\n};\r\n\r\nclass DifferentFormNoHeader extends FormPage {\r\n  constructor() { super() }\r\n  initHeader() {}\r\n  initForm() { console.log('Initializing different form') }\r\n}\r\n\r\nconst formPage = new FormPage();\r\n// Output:\r\n// Setting up base page\r\n// Initializing header\r\n// Initializing form\r\n\r\nconst formNoHeader = new FormNoHeader();\r\n// Output:\r\n// Setting up base page\r\n// Initializing form\r\n\r\nconst differentFormNoHeader = new DifferentFormNoHeader();\r\n// Output:\r\n// Setting up base page\r\n// Initializing different form\r\n```",
  "bodyHtml": "<p><img src=\"hero.jpg\" alt=\"wide\"></p>\n<p>Redux is a popular state management library for JavaScript apps that is routinely paired with frameworks like React or Angular. What follows is an explanation of how I’ve used Redux to make a production vanilla JS app more maintainable.</p>\n<p>I’m hoping this is useful for anyone out there who is looking for a real-world Redux + vanilla JS example beyond a button incrementer or to-do app.</p>\n<hr>\n<h1>Background</h1>\n<p>Let’s go back to late 2017/early 2018. The subject app is in production and has ~8 engineers actively developing. This ain’t your trendy universal React app. It’s purpose-built for managing content for our company.</p>\n<p>The backend framework is Django and includes Wagtail as a CMS. The frontend is babel-transpiled vanilla JS with SCSS as a preprocessor. Templates are all handled by Django’s built-in templating system.</p>\n<p>The frontend app has its roots in the Knockout JS framework, but this was reduced to vanilla JS in pursuit of faster page loads and script executions. Most of the frontend logic is meant to handle simple features like sharing to social networks, subscribing to a newsletter, and submitting forms.</p>\n<p>Each page stands alone and references its own template CSS file for styles, and template JS file for logic. Since we don’t use a frontend framework at runtime, the pages are much faster than our competitors.</p>\n<hr>\n<h1>Identifying the problems</h1>\n<p>As our app grew, we had to support more CMS templates that were used for even more pages. Common bugs would appear and reappear as we worked. Problems fell into two categories.</p>\n<h2>1. Code reuse was arbitrary and difficult</h2>\n<p>Our frontend code had duplication stemming from over-eager classical inheritance patterns. There were multiple levels of inheritance that had to be traversed to understand how a certain page’s logic would differ from another, very similar page.</p>\n<p>This got worse with time.</p>\n<p>Template functionality requirements were fluid. It was hard for newer hires to conform to the intricate inheritance layers when making changes. A ticket would be raised to fix a bug on one page with the assumption that it would apply to all templates. Unfortunately, that wasn’t the case.</p>\n<h2>2. Asynchronous data, without any management</h2>\n<p>Some code would make asynchronous data requests to a separate server. The response data existed only within the context of the requesting function. This was fine until we ran into situations where we wanted to share data between separate functions.</p>\n<p>Some features required data from multiple asynchronous functions and an engineer would have to manually invoke those functions and do it in the right order. It wasn’t immediately clear what that order was and why it was important until bugs cropped up in staging environments.</p>\n<p>It was especially awful with the duplication and confusing inheritance patterns already pervasive in the code. Plus, unit test coverage wasn’t very good.</p>\n<hr>\n<h1>Composing a solution with Redux</h1>\n<p>I audited the entirety of the frontend application and reduced all logic into small building blocks called <strong>features</strong>. These features almost never interacted with each other. They simply wanted to run, process some template data, attach event handlers to the DOM, and had no need to exist after that.</p>\n<p>Our app’s multilevel inheritance structure only existed to group features common to a template. I could accomplish the same thing and reduce cognitive load by simply composing our features together.</p>\n<p>for this, I used the <code>compose()</code> utility that Redux provides. See what kind of effect it has on the code below.</p>\n<h2>Before: multilevel inheritance</h2>\n<pre><code class=\"hljs\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BasePage</span> </span>{\n  <span class=\"hljs-keyword\">constructor</span>() { <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'Setting up base page'</span>) }\n};\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HeaderPage</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">BasePage</span> </span>{\n  <span class=\"hljs-keyword\">constructor</span>() {\n    <span class=\"hljs-keyword\">super</span>();\n    <span class=\"hljs-keyword\">this</span>.initHeader();\n  }\n  initHeader() { <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'Initializing header'</span>) }\n};\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">FormPage</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">HeaderPage</span> </span>{\n  <span class=\"hljs-keyword\">constructor</span>() {\n    <span class=\"hljs-keyword\">super</span>();\n    <span class=\"hljs-keyword\">this</span>.initForm();\n  }\n  initForm() { <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'Initializing form'</span>) }\n};\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">FormNoHeader</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">FormPage</span> </span>{\n  <span class=\"hljs-keyword\">constructor</span>() { <span class=\"hljs-keyword\">super</span>() }\n  <span class=\"hljs-comment\">// Empty method so that this.initHeader() in FormPage constructor does nothing</span>\n  initHeader() {}\n};\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">DifferentFormNoHeader</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">FormPage</span> </span>{\n  <span class=\"hljs-keyword\">constructor</span>() { <span class=\"hljs-keyword\">super</span>() }\n  initHeader() {}\n  initForm() { <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'Initializing different form'</span>) }\n}\n\n<span class=\"hljs-keyword\">const</span> formPage = <span class=\"hljs-keyword\">new</span> FormPage();\n<span class=\"hljs-comment\">// Output:</span>\n<span class=\"hljs-comment\">// Setting up base page</span>\n<span class=\"hljs-comment\">// Initializing header</span>\n<span class=\"hljs-comment\">// Initializing form</span>\n\n<span class=\"hljs-keyword\">const</span> formNoHeader = <span class=\"hljs-keyword\">new</span> FormNoHeader();\n<span class=\"hljs-comment\">// Output:</span>\n<span class=\"hljs-comment\">// Setting up base page</span>\n<span class=\"hljs-comment\">// Initializing form</span>\n\n<span class=\"hljs-keyword\">const</span> differentFormNoHeader = <span class=\"hljs-keyword\">new</span> DifferentFormNoHeader();\n<span class=\"hljs-comment\">// Output:</span>\n<span class=\"hljs-comment\">// Setting up base page</span>\n<span class=\"hljs-comment\">// Initializing different form</span></code></pre>",
  "dir": "content",
  "base": "2019-01-30.json",
  "ext": ".json",
  "sourceBase": "2019-01-30.md",
  "sourceExt": ".md"
}