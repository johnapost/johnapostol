{
  "title": "Using Redux with Vanilla JS",
  "preview": "What follows is an explanation of how I've used Redux to make a production vanilla JS app more maintainable.",
  "slug": "using-redux-with-vanilla-js",
  "tags": [
    "software",
    "javascript"
  ],
  "bodyContent": "![wide](hero.jpg)\r\n\r\nRedux is a popular state management library for JavaScript apps that is routinely paired with frameworks like React or Angular. What follows is an explanation of how Iâ€™ve used Redux to make a production vanilla JS app more maintainable.\r\n\r\nIâ€™m hoping this is useful for anyone out there who is looking for a real-world Redux + vanilla JS example beyond a button incrementer or to-do app.\r\n\r\n---\r\n\r\n# Background\r\n\r\nLetâ€™s go back to late 2017/early 2018. The subject app is in production and has ~8 engineers actively developing. This ainâ€™t your trendy universal React app. Itâ€™s purpose-built for managing content for our company.\r\n\r\nThe backend framework is Django and includes Wagtail as a CMS. The frontend is babel-transpiled vanilla JS with SCSS as a preprocessor. Templates are all handled by Djangoâ€™s built-in templating system.\r\n\r\nThe frontend app has its roots in the Knockout JS framework, but this was reduced to vanilla JS in pursuit of faster page loads and script executions. Most of the frontend logic is meant to handle simple features like sharing to social networks, subscribing to a newsletter, and submitting forms.\r\n\r\nEach page stands alone and references its own template CSS file for styles, and template JS file for logic. Since we donâ€™t use a frontend framework at runtime, the pages are much faster than our competitors.\r\n\r\n---\r\n\r\n# Identifying the problems\r\n\r\nAs our app grew, we had to support more CMS templates that were used for even more pages. Common bugs would appear and reappear as we worked. Problems fell into two categories.\r\n\r\n## 1. Code reuse was arbitrary and difficult\r\n\r\nOur frontend code had duplication stemming from over-eager classical inheritance patterns. There were multiple levels of inheritance that had to be traversed to understand how a certain pageâ€™s logic would differ from another, very similar page.\r\n\r\nThis got worse with time.\r\n\r\nTemplate functionality requirements were fluid. It was hard for newer hires to conform to the intricate inheritance layers when making changes. A ticket would be raised to fix a bug on one page with the assumption that it would apply to all templates. Unfortunately, that wasnâ€™t the case.\r\n\r\n## 2. Asynchronous data, without any management\r\n\r\nSome code would make asynchronous data requests to a separate server. The response data existed only within the context of the requesting function. This was fine until we ran into situations where we wanted to share data between separate functions.\r\n\r\nSome features required data from multiple asynchronous functions and an engineer would have to manually invoke those functions and do it in the right order. It wasnâ€™t immediately clear what that order was and why it was important until bugs cropped up in staging environments.\r\n\r\nIt was especially awful with the duplication and confusing inheritance patterns already pervasive in the code. Plus, unit test coverage wasnâ€™t very good.\r\n\r\n---\r\n\r\n# Composing a solution with Redux\r\n\r\nI audited the entirety of the frontend application and reduced all logic into small building blocks called **features**. These features almost never interacted with each other. They simply wanted to run, process some template data, attach event handlers to the DOM, and had no need to exist after that.\r\n\r\nOur appâ€™s multilevel inheritance structure only existed to group features common to a template. I could accomplish the same thing and reduce cognitive load by simply composing our features together.\r\n\r\nfor this, I used the `compose()` utility that Redux provides. See what kind of effect it has on the code below.\r\n\r\n## Before: multilevel inheritance\r\n\r\n```javascript\r\nclass BasePage {\r\n  constructor() { console.log('Setting up base page') }\r\n};\r\n\r\nclass HeaderPage extends BasePage {\r\n  constructor() {\r\n    super();\r\n    this.initHeader();\r\n  }\r\n  initHeader() { console.log('Initializing header') }\r\n};\r\n\r\nclass FormPage extends HeaderPage {\r\n  constructor() {\r\n    super();\r\n    this.initForm();\r\n  }\r\n  initForm() { console.log('Initializing form') }\r\n};\r\n\r\nclass FormNoHeader extends FormPage {\r\n  constructor() { super() }\r\n  // Empty method so that this.initHeader() in FormPage constructor does nothing\r\n  initHeader() {}\r\n};\r\n\r\nclass DifferentFormNoHeader extends FormPage {\r\n  constructor() { super() }\r\n  initHeader() {}\r\n  initForm() { console.log('Initializing different form') }\r\n}\r\n\r\nconst formPage = new FormPage();\r\n// Output:\r\n// Setting up base page\r\n// Initializing header\r\n// Initializing form\r\n\r\nconst formNoHeader = new FormNoHeader();\r\n// Output:\r\n// Setting up base page\r\n// Initializing form\r\n\r\nconst differentFormNoHeader = new DifferentFormNoHeader();\r\n// Output:\r\n// Setting up base page\r\n// Initializing different form\r\n```\r\n*Most problems arose when we wanted to copy template functionality except for one or two pieces of logic.*\r\n\r\n## AFTER: functional composition\r\n\r\n```javascript\r\nimport { compose } from 'redux';\r\n\r\nconst setup = () => { console.log('Setting up base page') };\r\nconst initHeader = () => { console.log('Initializing header') };\r\nconst initForm = () => { console.log('Initializing form') };\r\nconst differentForm = () => { console.log('Initializing different form') };\r\n\r\nconst formPage = compose(initForm, initHeader, setup)();\r\n// Output:\r\n// Setting up base page\r\n// Initializing header\r\n// Initializing form\r\n\r\nconst formNoHeader = compose(initForm, setup)();\r\n// Output:\r\n// Setting up base page\r\n// Initializing form\r\n\r\nconst differentFormNoHeader = compose(differntForm, setup)();\r\n// Output:\r\n// Setting up base page\r\n// Initializing different form\r\n```\r\n*Beautiful*\r\n\r\nSwitching to functional composition proved to be highly beneficial. I was able to remove all logic related to individual templates since they are just comprised of features. This reduced the complexity of our frontend immensely!\r\n\r\nEach feature comes with its own set of unit tests. These are easy to write, because of the isolated nature of the code. If unit tests are easy to write, they will get written more often, helping the team keep up with maintenance.\r\n\r\nBy using `compose()` we can also bundle features together and import that bundle all at once. This is helpful for when we create a new Django template X that needs to be like template Y, but with the addition of feature Z.\r\n\r\n## Bundled features\r\n\r\n```javascript\r\n\r\nimport { compose } from 'redux';\r\n\r\n// Features\r\nconst setup = () => { console.log('Setting up base page') };\r\nconst initHeader = () => { console.log('Initializing header') };\r\nconst initForm = () => { console.log('Initializing form') };\r\nconst initSlider = () => { console.log('Initializing slider') };\r\n\r\n// Similar to the BasePage and HeaderPage classes\r\nconst basePage = setup();\r\nconst headerPage = initHeader(basePage);\r\n\r\n// We can take the headerPage bundle and compose off of that\r\nconst formSliderPage = compose(initSlider, initForm)(headerPage);\r\n// Output:\r\n// Setting up base page\r\n// Initializing header\r\n// Initializing form\r\n// Initializing slider\r\n```\r\n\r\n# Sharing data with Redux\r\n\r\nI didn't bring Redux in as a dependency just for `compose()`. I also needed a way to share data between features and manage async calls. I needed to use a data store.\r\n\r\nTo be a feature, a function..\r\n\r\n* must be unary (accept only the Redux store as an argument)\r\n* must return our appâ€™s store for the next function in the chain\r\n* must not be async\r\n\r\n## A typical feature\r\n\r\n```javascript\r\nconst makeLinksAlert = store => {\r\n  const links = document.querySelector('a')\r\n  Array.from(links).forEach(el => {\r\n    el.addEventListener(\"click\", () => { alert('alert!') });\r\n  });\r\n  return store;\r\n};\r\n```\r\n*A lot of our features do small things like this.*\r\n\r\nEach feature has access to the [Redux store](https://redux.js.org/basics/store#store), which is powerful.\r\n\r\nAt the same time, itâ€™s important to restrict features from blocking on async requests during the initial script evaluation. It would be disastrous if a form wasnâ€™t responsive as soon as it was visible. So I only `dispatch()` and `getState()` when it makes sense (typically on user interaction).\r\n\r\nThe Redux store maintains the state of important async calls. I dispatch relevant actions as async calls are made inside features. Features can subscribe to the store and fire once a value is truthy. This provides a way to chain asynchronous calls between features without having to rely on bloated Promise chains.\r\n\r\nI created a simple subscribe function to accomplish this. Note that it also unsubscribes once the callback fires.\r\n\r\n## Subscribe utility\r\n\r\n```javascript\r\nconst passConditions = (conditions, state) =>\r\n  conditions.every(condition => {\r\n    const path = condition.split(\".\");\r\n    // Check to see if condition values are truthy\r\n    return !!path.reduce(\r\n      (accum, curr) => (accum && accum[curr] ? accum[curr] : null),\r\n      state\r\n    );\r\n  });\r\n\r\n// Conditions are an array of string paths to access store keys.\r\n// [\"quoteId.value\"] would only fire if nested key value was truthy.\r\n// A store like { quoteId: { value: true } } would suffice.\r\nexport default (conditions, callback) => store => {\r\n  let fired = false;\r\n  // The redux store subscribe returns an unsubscribe function\r\n  const unsubscribe = store.subscribe(() => {\r\n    const state = store.getState();\r\n    if (!passConditions(conditions, state)) return;\r\n    // This line is to pass tests\r\n    if (unsubscribe) unsubscribe();\r\n    // The unsubscribe call is not enough to ensure the callback only fires once\r\n    if (!fired) callback(state, store);\r\n    fired = true;\r\n  });\r\n  return store;\r\n};\r\n```\r\n\r\nThere are circumstances where a feature is waiting on multiple async calls to fire. Simply subscribe to both async values and wait for them both to be valid.\r\n\r\n## Using subscribe utility\r\n\r\n```javascript\r\nimport subscribe from './subscribe'\r\n\r\n// Store state\r\n// {\r\n//   form: {\r\n//     loaded: true,\r\n//     emailInput: {\r\n//       value: 'email@domain.com'\r\n//     }\r\n//   }\r\n// }\r\n\r\nconst validateInput = \r\n  subscribe(['form.loaded', 'form.emailInput.value'], state => {\r\n    console.log('Validating input');\r\n  });\r\n```\r\n*The validateInput feature will fire once when both conditions are truthy. It will unsubscribe afterwards.*\r\n\r\n---\r\n\r\n# Conclusion\r\nIâ€™m pleased to have found a use for Redux outside of React and to have applied some of the functional programming techniques Iâ€™ve been studying. The refactors have been thriving in production for a year now and our frontend code is healthier than ever.\r\n\r\nBenefits recap:\r\n\r\n* Removal of template JS logic\r\n* Smaller, focused units of code\r\n* Easier to test\r\n* Less async bugs\r\n\r\nThat said, Iâ€™m still working to improve on this concept.\r\n\r\nWeâ€™ve had engineers import a feature, without realizing that it already exists in the compose chain via a feature bundle. This means that feature would execute twice. Iâ€™m working on a solution for that.\r\n\r\nSince template JS files have become tacit compose functions, I can evaluate the Django template at compile time and come up with the features that should be composed. Tie that to the CMS blocks, deploy dynamic JS to a CDN, and now we can build features without worrying about templates at all.\r\n\r\nMaybe Iâ€™ll have a follow-up next year. ðŸ˜„",
  "bodyHtml": "<p><img src=\"hero.jpg\" alt=\"wide\"></p>\n<p>Redux is a popular state management library for JavaScript apps that is routinely paired with frameworks like React or Angular. What follows is an explanation of how Iâ€™ve used Redux to make a production vanilla JS app more maintainable.</p>\n<p>Iâ€™m hoping this is useful for anyone out there who is looking for a real-world Redux + vanilla JS example beyond a button incrementer or to-do app.</p>\n<hr>\n<h1>Background</h1>\n<p>Letâ€™s go back to late 2017/early 2018. The subject app is in production and has ~8 engineers actively developing. This ainâ€™t your trendy universal React app. Itâ€™s purpose-built for managing content for our company.</p>\n<p>The backend framework is Django and includes Wagtail as a CMS. The frontend is babel-transpiled vanilla JS with SCSS as a preprocessor. Templates are all handled by Djangoâ€™s built-in templating system.</p>\n<p>The frontend app has its roots in the Knockout JS framework, but this was reduced to vanilla JS in pursuit of faster page loads and script executions. Most of the frontend logic is meant to handle simple features like sharing to social networks, subscribing to a newsletter, and submitting forms.</p>\n<p>Each page stands alone and references its own template CSS file for styles, and template JS file for logic. Since we donâ€™t use a frontend framework at runtime, the pages are much faster than our competitors.</p>\n<hr>\n<h1>Identifying the problems</h1>\n<p>As our app grew, we had to support more CMS templates that were used for even more pages. Common bugs would appear and reappear as we worked. Problems fell into two categories.</p>\n<h2>1. Code reuse was arbitrary and difficult</h2>\n<p>Our frontend code had duplication stemming from over-eager classical inheritance patterns. There were multiple levels of inheritance that had to be traversed to understand how a certain pageâ€™s logic would differ from another, very similar page.</p>\n<p>This got worse with time.</p>\n<p>Template functionality requirements were fluid. It was hard for newer hires to conform to the intricate inheritance layers when making changes. A ticket would be raised to fix a bug on one page with the assumption that it would apply to all templates. Unfortunately, that wasnâ€™t the case.</p>\n<h2>2. Asynchronous data, without any management</h2>\n<p>Some code would make asynchronous data requests to a separate server. The response data existed only within the context of the requesting function. This was fine until we ran into situations where we wanted to share data between separate functions.</p>\n<p>Some features required data from multiple asynchronous functions and an engineer would have to manually invoke those functions and do it in the right order. It wasnâ€™t immediately clear what that order was and why it was important until bugs cropped up in staging environments.</p>\n<p>It was especially awful with the duplication and confusing inheritance patterns already pervasive in the code. Plus, unit test coverage wasnâ€™t very good.</p>\n<hr>\n<h1>Composing a solution with Redux</h1>\n<p>I audited the entirety of the frontend application and reduced all logic into small building blocks called <strong>features</strong>. These features almost never interacted with each other. They simply wanted to run, process some template data, attach event handlers to the DOM, and had no need to exist after that.</p>\n<p>Our appâ€™s multilevel inheritance structure only existed to group features common to a template. I could accomplish the same thing and reduce cognitive load by simply composing our features together.</p>\n<p>for this, I used the <code>compose()</code> utility that Redux provides. See what kind of effect it has on the code below.</p>\n<h2>Before: multilevel inheritance</h2>\n<pre><code class=\"hljs\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BasePage</span> </span>{\n  <span class=\"hljs-keyword\">constructor</span>() { <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'Setting up base page'</span>) }\n};\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HeaderPage</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">BasePage</span> </span>{\n  <span class=\"hljs-keyword\">constructor</span>() {\n    <span class=\"hljs-keyword\">super</span>();\n    <span class=\"hljs-keyword\">this</span>.initHeader();\n  }\n  initHeader() { <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'Initializing header'</span>) }\n};\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">FormPage</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">HeaderPage</span> </span>{\n  <span class=\"hljs-keyword\">constructor</span>() {\n    <span class=\"hljs-keyword\">super</span>();\n    <span class=\"hljs-keyword\">this</span>.initForm();\n  }\n  initForm() { <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'Initializing form'</span>) }\n};\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">FormNoHeader</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">FormPage</span> </span>{\n  <span class=\"hljs-keyword\">constructor</span>() { <span class=\"hljs-keyword\">super</span>() }\n  <span class=\"hljs-comment\">// Empty method so that this.initHeader() in FormPage constructor does nothing</span>\n  initHeader() {}\n};\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">DifferentFormNoHeader</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">FormPage</span> </span>{\n  <span class=\"hljs-keyword\">constructor</span>() { <span class=\"hljs-keyword\">super</span>() }\n  initHeader() {}\n  initForm() { <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'Initializing different form'</span>) }\n}\n\n<span class=\"hljs-keyword\">const</span> formPage = <span class=\"hljs-keyword\">new</span> FormPage();\n<span class=\"hljs-comment\">// Output:</span>\n<span class=\"hljs-comment\">// Setting up base page</span>\n<span class=\"hljs-comment\">// Initializing header</span>\n<span class=\"hljs-comment\">// Initializing form</span>\n\n<span class=\"hljs-keyword\">const</span> formNoHeader = <span class=\"hljs-keyword\">new</span> FormNoHeader();\n<span class=\"hljs-comment\">// Output:</span>\n<span class=\"hljs-comment\">// Setting up base page</span>\n<span class=\"hljs-comment\">// Initializing form</span>\n\n<span class=\"hljs-keyword\">const</span> differentFormNoHeader = <span class=\"hljs-keyword\">new</span> DifferentFormNoHeader();\n<span class=\"hljs-comment\">// Output:</span>\n<span class=\"hljs-comment\">// Setting up base page</span>\n<span class=\"hljs-comment\">// Initializing different form</span></code></pre><p><em>Most problems arose when we wanted to copy template functionality except for one or two pieces of logic.</em></p>\n<h2>AFTER: functional composition</h2>\n<pre><code class=\"hljs\"><span class=\"hljs-keyword\">import</span> { compose } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'redux'</span>;\n\n<span class=\"hljs-keyword\">const</span> setup = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> { <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'Setting up base page'</span>) };\n<span class=\"hljs-keyword\">const</span> initHeader = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> { <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'Initializing header'</span>) };\n<span class=\"hljs-keyword\">const</span> initForm = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> { <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'Initializing form'</span>) };\n<span class=\"hljs-keyword\">const</span> differentForm = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> { <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'Initializing different form'</span>) };\n\n<span class=\"hljs-keyword\">const</span> formPage = compose(initForm, initHeader, setup)();\n<span class=\"hljs-comment\">// Output:</span>\n<span class=\"hljs-comment\">// Setting up base page</span>\n<span class=\"hljs-comment\">// Initializing header</span>\n<span class=\"hljs-comment\">// Initializing form</span>\n\n<span class=\"hljs-keyword\">const</span> formNoHeader = compose(initForm, setup)();\n<span class=\"hljs-comment\">// Output:</span>\n<span class=\"hljs-comment\">// Setting up base page</span>\n<span class=\"hljs-comment\">// Initializing form</span>\n\n<span class=\"hljs-keyword\">const</span> differentFormNoHeader = compose(differntForm, setup)();\n<span class=\"hljs-comment\">// Output:</span>\n<span class=\"hljs-comment\">// Setting up base page</span>\n<span class=\"hljs-comment\">// Initializing different form</span></code></pre><p><em>Beautiful</em></p>\n<p>Switching to functional composition proved to be highly beneficial. I was able to remove all logic related to individual templates since they are just comprised of features. This reduced the complexity of our frontend immensely!</p>\n<p>Each feature comes with its own set of unit tests. These are easy to write, because of the isolated nature of the code. If unit tests are easy to write, they will get written more often, helping the team keep up with maintenance.</p>\n<p>By using <code>compose()</code> we can also bundle features together and import that bundle all at once. This is helpful for when we create a new Django template X that needs to be like template Y, but with the addition of feature Z.</p>\n<h2>Bundled features</h2>\n<pre><code class=\"hljs\"><span class=\"hljs-keyword\">import</span> { compose } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'redux'</span>;\n\n<span class=\"hljs-comment\">// Features</span>\n<span class=\"hljs-keyword\">const</span> setup = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> { <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'Setting up base page'</span>) };\n<span class=\"hljs-keyword\">const</span> initHeader = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> { <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'Initializing header'</span>) };\n<span class=\"hljs-keyword\">const</span> initForm = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> { <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'Initializing form'</span>) };\n<span class=\"hljs-keyword\">const</span> initSlider = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> { <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'Initializing slider'</span>) };\n\n<span class=\"hljs-comment\">// Similar to the BasePage and HeaderPage classes</span>\n<span class=\"hljs-keyword\">const</span> basePage = setup();\n<span class=\"hljs-keyword\">const</span> headerPage = initHeader(basePage);\n\n<span class=\"hljs-comment\">// We can take the headerPage bundle and compose off of that</span>\n<span class=\"hljs-keyword\">const</span> formSliderPage = compose(initSlider, initForm)(headerPage);\n<span class=\"hljs-comment\">// Output:</span>\n<span class=\"hljs-comment\">// Setting up base page</span>\n<span class=\"hljs-comment\">// Initializing header</span>\n<span class=\"hljs-comment\">// Initializing form</span>\n<span class=\"hljs-comment\">// Initializing slider</span></code></pre><h1>Sharing data with Redux</h1>\n<p>I didn't bring Redux in as a dependency just for <code>compose()</code>. I also needed a way to share data between features and manage async calls. I needed to use a data store.</p>\n<p>To be a feature, a function..</p>\n<ul>\n<li>must be unary (accept only the Redux store as an argument)</li>\n<li>must return our appâ€™s store for the next function in the chain</li>\n<li>must not be async</li>\n</ul>\n<h2>A typical feature</h2>\n<pre><code class=\"hljs\"><span class=\"hljs-keyword\">const</span> makeLinksAlert = <span class=\"hljs-function\"><span class=\"hljs-params\">store</span> =&gt;</span> {\n  <span class=\"hljs-keyword\">const</span> links = <span class=\"hljs-built_in\">document</span>.querySelector(<span class=\"hljs-string\">'a'</span>)\n  <span class=\"hljs-built_in\">Array</span>.from(links).forEach(<span class=\"hljs-function\"><span class=\"hljs-params\">el</span> =&gt;</span> {\n    el.addEventListener(<span class=\"hljs-string\">\"click\"</span>, () =&gt; { alert(<span class=\"hljs-string\">'alert!'</span>) });\n  });\n  <span class=\"hljs-keyword\">return</span> store;\n};</code></pre><p><em>A lot of our features do small things like this.</em></p>\n<p>Each feature has access to the <a href=\"https://redux.js.org/basics/store#store\">Redux store</a>, which is powerful.</p>\n<p>At the same time, itâ€™s important to restrict features from blocking on async requests during the initial script evaluation. It would be disastrous if a form wasnâ€™t responsive as soon as it was visible. So I only <code>dispatch()</code> and <code>getState()</code> when it makes sense (typically on user interaction).</p>\n<p>The Redux store maintains the state of important async calls. I dispatch relevant actions as async calls are made inside features. Features can subscribe to the store and fire once a value is truthy. This provides a way to chain asynchronous calls between features without having to rely on bloated Promise chains.</p>\n<p>I created a simple subscribe function to accomplish this. Note that it also unsubscribes once the callback fires.</p>\n<h2>Subscribe utility</h2>\n<pre><code class=\"hljs\"><span class=\"hljs-keyword\">const</span> passConditions = <span class=\"hljs-function\">(<span class=\"hljs-params\">conditions, state</span>) =&gt;</span>\n  conditions.every(<span class=\"hljs-function\"><span class=\"hljs-params\">condition</span> =&gt;</span> {\n    <span class=\"hljs-keyword\">const</span> path = condition.split(<span class=\"hljs-string\">\".\"</span>);\n    <span class=\"hljs-comment\">// Check to see if condition values are truthy</span>\n    <span class=\"hljs-keyword\">return</span> !!path.reduce(\n      <span class=\"hljs-function\">(<span class=\"hljs-params\">accum, curr</span>) =&gt;</span> (accum &amp;&amp; accum[curr] ? accum[curr] : <span class=\"hljs-literal\">null</span>),\n      state\n    );\n  });\n\n<span class=\"hljs-comment\">// Conditions are an array of string paths to access store keys.</span>\n<span class=\"hljs-comment\">// [\"quoteId.value\"] would only fire if nested key value was truthy.</span>\n<span class=\"hljs-comment\">// A store like { quoteId: { value: true } } would suffice.</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> (conditions, callback) =&gt; <span class=\"hljs-function\"><span class=\"hljs-params\">store</span> =&gt;</span> {\n  <span class=\"hljs-keyword\">let</span> fired = <span class=\"hljs-literal\">false</span>;\n  <span class=\"hljs-comment\">// The redux store subscribe returns an unsubscribe function</span>\n  <span class=\"hljs-keyword\">const</span> unsubscribe = store.subscribe(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n    <span class=\"hljs-keyword\">const</span> state = store.getState();\n    <span class=\"hljs-keyword\">if</span> (!passConditions(conditions, state)) <span class=\"hljs-keyword\">return</span>;\n    <span class=\"hljs-comment\">// This line is to pass tests</span>\n    <span class=\"hljs-keyword\">if</span> (unsubscribe) unsubscribe();\n    <span class=\"hljs-comment\">// The unsubscribe call is not enough to ensure the callback only fires once</span>\n    <span class=\"hljs-keyword\">if</span> (!fired) callback(state, store);\n    fired = <span class=\"hljs-literal\">true</span>;\n  });\n  <span class=\"hljs-keyword\">return</span> store;\n};</code></pre><p>There are circumstances where a feature is waiting on multiple async calls to fire. Simply subscribe to both async values and wait for them both to be valid.</p>\n<h2>Using subscribe utility</h2>\n<pre><code class=\"hljs\"><span class=\"hljs-keyword\">import</span> subscribe <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./subscribe'</span>\n\n<span class=\"hljs-comment\">// Store state</span>\n<span class=\"hljs-comment\">// {</span>\n<span class=\"hljs-comment\">//   form: {</span>\n<span class=\"hljs-comment\">//     loaded: true,</span>\n<span class=\"hljs-comment\">//     emailInput: {</span>\n<span class=\"hljs-comment\">//       value: 'email@domain.com'</span>\n<span class=\"hljs-comment\">//     }</span>\n<span class=\"hljs-comment\">//   }</span>\n<span class=\"hljs-comment\">// }</span>\n\n<span class=\"hljs-keyword\">const</span> validateInput = \n  subscribe([<span class=\"hljs-string\">'form.loaded'</span>, <span class=\"hljs-string\">'form.emailInput.value'</span>], state =&gt; {\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'Validating input'</span>);\n  });</code></pre><p><em>The validateInput feature will fire once when both conditions are truthy. It will unsubscribe afterwards.</em></p>\n<hr>\n<h1>Conclusion</h1>\n<p>Iâ€™m pleased to have found a use for Redux outside of React and to have applied some of the functional programming techniques Iâ€™ve been studying. The refactors have been thriving in production for a year now and our frontend code is healthier than ever.</p>\n<p>Benefits recap:</p>\n<ul>\n<li>Removal of template JS logic</li>\n<li>Smaller, focused units of code</li>\n<li>Easier to test</li>\n<li>Less async bugs</li>\n</ul>\n<p>That said, Iâ€™m still working to improve on this concept.</p>\n<p>Weâ€™ve had engineers import a feature, without realizing that it already exists in the compose chain via a feature bundle. This means that feature would execute twice. Iâ€™m working on a solution for that.</p>\n<p>Since template JS files have become tacit compose functions, I can evaluate the Django template at compile time and come up with the features that should be composed. Tie that to the CMS blocks, deploy dynamic JS to a CDN, and now we can build features without worrying about templates at all.</p>\n<p>Maybe Iâ€™ll have a follow-up next year. ðŸ˜„</p>\n",
  "dir": "content",
  "base": "2019-01-30.json",
  "ext": ".json",
  "sourceBase": "2019-01-30.md",
  "sourceExt": ".md"
}