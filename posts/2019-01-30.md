---
date: "2019-01-30"
title: "Using Redux with Vanilla JS"
preview: "What follows is an explanation of how I've used Redux to make a production vanilla JS app more maintainable."
slug: "using-redux-with-vanilla-js"
tags: ["software", "javascript"]
---

![wide](hero.jpg)

Redux is a popular state management library for JavaScript apps that is routinely paired with frameworks like React or Angular. What follows is an explanation of how I’ve used Redux to make a production vanilla JS app more maintainable.

I’m hoping this is useful for anyone out there who is looking for a real-world Redux + vanilla JS example beyond a button incrementer or to-do app.

---

# Background

Let’s go back to late 2017/early 2018. The subject app is in production and has ~8 engineers actively developing. This ain’t your trendy universal React app. It’s purpose-built for managing content for our company.

The backend framework is Django and includes Wagtail as a CMS. The frontend is babel-transpiled vanilla JS with SCSS as a preprocessor. Templates are all handled by Django’s built-in templating system.

The frontend app has its roots in the Knockout JS framework, but this was reduced to vanilla JS in pursuit of faster page loads and script executions. Most of the frontend logic is meant to handle simple features like sharing to social networks, subscribing to a newsletter, and submitting forms.

Each page stands alone and references its own template CSS file for styles, and template JS file for logic. Since we don’t use a frontend framework at runtime, the pages are much faster than our competitors.

---

# Identifying the problems

As our app grew, we had to support more CMS templates that were used for even more pages. Common bugs would appear and reappear as we worked. Problems fell into two categories.

## 1. Code reuse was arbitrary and difficult

Our frontend code had duplication stemming from over-eager classical inheritance patterns. There were multiple levels of inheritance that had to be traversed to understand how a certain page’s logic would differ from another, very similar page.

This got worse with time.

Template functionality requirements were fluid. It was hard for newer hires to conform to the intricate inheritance layers when making changes. A ticket would be raised to fix a bug on one page with the assumption that it would apply to all templates. Unfortunately, that wasn’t the case.

## 2. Asynchronous data, without any management

Some code would make asynchronous data requests to a separate server. The response data existed only within the context of the requesting function. This was fine until we ran into situations where we wanted to share data between separate functions.

Some features required data from multiple asynchronous functions and an engineer would have to manually invoke those functions and do it in the right order. It wasn’t immediately clear what that order was and why it was important until bugs cropped up in staging environments.

It was especially awful with the duplication and confusing inheritance patterns already pervasive in the code. Plus, unit test coverage wasn’t very good.
